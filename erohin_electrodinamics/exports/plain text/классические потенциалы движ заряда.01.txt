
restart; clear

«Пусть имеется заряд, движущийся вдоль оси x со скоростью v (рис.5-1). Нас
интересуют потенциалы в точке Р (x,y,z). Если t = 0 - момент, в который заряд
проходит через начало координат, то в момент t он окажется в точке x = vt, y = z
= 0. А нам нужно знать его положение с учетом запаздывания, т.е. положение в
момент t' = t – r'/c (5.1), где r2 – расстояние от заряда до точки Р в этот
запаздывающий момент. В это более раннее время t' заряд был в x – vt2, так что
r__zap := proc (t__zap) options operator, arrow; sqrt((x-v*t__zap)^2+y^2+z^2)
end proc (5.2)
              /              2    2    2\
t__zap -> sqrt\(x - v t__zap)  + y  + z /

Чтобы найти r2 или t2, это уравнение надо сопоставить c (5.1). Исключим сперва
r2, решив (5.1) относительно r2, и подставив в (5.2). Возведя затем обе части в
квадрат, получим c^2*(t-t__zap)^2 = (-t__zap*v+x)^2+y^2+z^2
> 

solve(c^2*(t-t__zap)^2 = (-t__zap*v+x)^2+y^2+z^2, t__zap)
        /          
   1    | 2        
------- \c  t - v x
 2    2            
c  - v             

                                                                    (1/2)\    
     / 2  2  2      2          2  2    2  2    2  2    2  2    2  2\     |    
   + \c  t  v  - 2 c  t v x + c  x  + c  y  + c  z  - v  y  - v  z /     /, - 

          /           
     1    |  2        
  ------- \-c  t + v x
   2    2             
  c  - v              

                                                                    (1/2)\
     / 2  2  2      2          2  2    2  2    2  2    2  2    2  2\     |
   + \c  t  v  - 2 c  t v x + c  x  + c  y  + c  z  - v  y  - v  z /     /
При решении квадратного уравнения (-t__zap*v+x)^2+y^2+z^2-c(t-t__zap)^4
относительно времени запаздывания t__zap с помощью дискриминанта возникает два
решения t__zap1 и t__zap2. Первое решение приводится в учебнике Фейнмана, второе
молчаливо отбрасывается

t__zap1 := (t-x*v/c^2-sqrt((-t*v+x)^2+(1-v^2/c^2)*(y^2+z^2))/c)/(1-v^2/c^2);
t__zap2 := (t-x*v/c^2+sqrt((-t*v+x)^2+(1-v^2/c^2)*(y^2+z^2))/c)/(1-v^2/c^2)



> t__zap1 := (t-x*v/c^2-sqrt((-t*v+x)^2+(1-v^2/c^2)*(y^2+z^2))/c)/(1-v^2/c^2);
                                                          (1/2)
                        /              /     2\          \     
                        |          2   |    v | / 2    2\|     
                        |(-t v + x)  + |1 - --| \y  + z /|     
                        |              |     2|          |     
                  x v   \              \    c /          /     
              t - --- - ---------------------------------------
                   2                       c                   
                  c                                            
              -------------------------------------------------
                                        2                      
                                       v                       
                                   1 - --                      
                                        2                      
                                       c                       


Какой физический смысл первого решения, а какой второго? Подставляем оба решения
для времени запаздывания в (5.1) И для обоих решений находим радиус Л-В


r__zap1 := c*(t-t__zap1); simplify(r__zap1); cos_alpha_1 :=
(-t__zap1*v+x)/r__zap1; v_r__zap1 := v*r__zap1*cos_alpha_1; K__1 :=
simplify(r__zap1-v_r__zap1/c)
                                                                    (1/2)
     / 2  2  2      2          2  2    2  2    2  2    2  2    2  2\     
     |c  t  v  - 2 c  t v x + c  x  + c  y  + c  z  - v  y  - v  z |     
     |-------------------------------------------------------------|     
     |                              2                              |     
     \                             c                               /     


r__zap2 := c*(t-t__zap2); cos_alpha_2 := (-t__zap2*v+x)/r__zap2; v_r__zap2 :=
v*r__zap2*cos_alpha_2; K__2 := simplify(r__zap2-v_r__zap2/c)
                                                               (1/2)
           // 2  2              2    2    2\  2    2 / 2    2\\     
           |\t  v  - 2 t v x + x  + y  + z / c  - v  \y  + z /|     
          -|--------------------------------------------------|     
           |                         2                        |     
           \                        c                         /     

Поле определяется состоянием заряда в запаздывающих координатах. При y = z = 0
радиус Л-В впереди заряда равен -t*v+x , а позади него -t*v-x .

simplify(subs(y = 0, z = 0, K__1)) simplify(subs(y = 0, z = 0, K__2))
                           csgn(t v - x) (t v - x)
                           (-t v + x) csgn(t v - x)


csgn(t*v-x) - это знак функции t*v-x
                                   t v - x

Запаздывающий радиус для движущегося заряда при y = z = 0 будет R' = x
(рис.7-2).

assume(x > v*t)
simplify(subs(y = 0, z = 0, r__zap1)), simplify(subs(y = 0, z = 0, r__zap2))
                                  (t v - x) c
                                - -----------
                                     c - v   
                                 (t v - x) c
                                 -----------
                                    c + v   

assume(x < v*t)
simplify(subs(y = 0, z = 0, r__zap1)), simplify(subs(y = 0, z = 0, r__zap2))
                                 (t v - x) c
                                 -----------
                                    c + v   
                                  (t v - x) c
                                - -----------
                                     c - v   

plot(simplify(subs(z = 0, v = 2, c = 3, y = 0, t = 0, [r__zap1, r__zap2])))






K := sqrt((-t*v+x)^2+(1-v^2/c^2)*(y^2+z^2)); plot(simplify(subs(z = 0, v = 2.99,
c = 3, y = 0, t = 0, 1/K)))





plot(subs(y = 0, z = 0, t = 0, v = 1.5, c = 3, [t__zap1, t__zap2]), x)


plot3d(subs(y = 0, z = 0, v = 1.5, c = 3, t-t__zap1))



plot(subs(y = 0, z = 0, t = 0, v = 1, c = 3, a = 0, 1/r__zap2(t__zap1)), x)



Равноускоренное движение


s := proc (t, v, a) options operator, arrow; v*t+(1/2)*a*t^2 end proc

                   1    2
(t, v, a) -> v t + - a t 
                   2     
r__zap := proc (t__zap) options operator, arrow; sqrt((x-s(t__zap, v,
a))^2+y^2+z^2) end proc
              /                     2    2    2\
t__zap -> sqrt\(x - s(t__zap, v, a))  + y  + z /


solve(c(t-t__zap) = r__zap(t__zap), t__zap)
        / 2   4         3             2      2   2                         2
  RootOf\a  _Z  + 4 v _Z  a - 4 x a _Z  + 4 v  _Z  - 8 x v _Z - 4 c(t - _Z) 

          2      2      2\
     + 4 x  + 4 y  + 4 z /


